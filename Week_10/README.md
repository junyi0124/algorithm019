## 毕业总结

### 1. 感想部分
70天，10周时间，并不长。但是这段时间的成长经历，让我认识到，只要方法得当，有足够的意志去执行，成果还是非常可观的。原本打算靠学习一门课，利用课后企业内推去做敲门砖，结果学习到最后，发现自己已经完成了蜕变成为了原来眼中的“别的程序员“。这种反差非常震撼。
### 2. 学习方法
个人觉得覃超老师总结的学习方法非常好，记录一下：
- 切题四步法：
  1. Clarification：明确题目意思、边界、数据规模
  1. Possible solutions：穷尽所有可能的解法（ - compare time/space - optimal solution）
  1. Coding：代码简洁、高性能、美感
  1. Test cases: 适当测试样例
- 五毒神掌：
  1. 第一遍：不要死磕，要看代码学习（一定要看国际版的高票回答）
  1. 第二遍：自己写
  1. 第三遍：24小时后
  1. 第四遍：一周后
  1. 第五遍：面试前


### 3. 知识点
- 解题中要加速的两个核心思想是：第一要升维，第二是空间换时间。

- 用递归求解有关树的问题很方便。

- 递归模板主要为四个部分：
    1. Recursion terminator. 必不可少的递归终结条件（否则就成了无限递归）。
    2. Process. 处理当前层逻辑。
    3. Drill down. 下探到下一层。
    4. Revert. 清理当前层。

- 动态规划：
    * 方法一：先分治，再记忆化搜索
    * 方法二：自底向上（for循环）-> 动态规划终极形态

- 排序算法：
    初级排序 - O(n^2)
    1. 选择排序（Selection Sort）
    每次找最小值，然后放到待排序数组的起始位置。
    2. 插入排序（Insertion Sort）
    从前到后逐步构建有序序列；对于未排序数据，在已排序序列中从后
    向前扫描，找到相应位置并插入。
    3. 冒泡排序（Bubble Sort）
    嵌套循环，每次查看相邻的元素如果逆序，则交换。

    高级排序 - O(N*LogN)：
    1. 快速排序（Quick Sort）
    2. 归并排序（Merge Sort） — 分治
    3. 堆排序（Heap Sort）

### 最后的一点儿思考
我们花了钱，使用本可以和家人玩乐的时间去学习是为了什么：为了在短时间内使用 __正确学习方法__ ，获得一个比较大的提升，提升自我价值，这样就可以在市场中获得更高的对价。
那么本质上，这门课程就是在帮助我们提升个人在整体程序员群体中的代码能力排名，只要有足够多的人继续苟且，而一部分人放弃一时的享乐，参与到了这样高效的学习中来，这种自我提升效果就越好。
